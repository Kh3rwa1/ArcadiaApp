<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Crystal Caverns</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0818;
            font-family: -apple-system, system-ui, sans-serif;
            touch-action: none
        }

        #game {
            position: absolute;
            inset: 0
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: env(safe-area-inset-top, 20px) 20px 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10
        }

        .stat {
            text-align: center
        }

        .stat-value {
            font-size: 28px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 20px rgba(168, 85, 247, 0.8)
        }

        .stat-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 2px
        }

        #start {
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, #0a0818, #150820);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100
        }

        #start.hidden {
            display: none
        }

        .title {
            font-size: 48px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 40px #a855f7;
            letter-spacing: 4px
        }

        .subtitle {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 8px;
            margin-top: 8px
        }

        .play-btn {
            margin-top: 40px;
            padding: 16px 50px;
            font-size: 14px;
            font-weight: 700;
            color: #0a0818;
            background: linear-gradient(135deg, #a855f7, #ec4899);
            border: none;
            border-radius: 30px;
            text-transform: uppercase;
            letter-spacing: 4px
        }

        #win {
            position: absolute;
            inset: 0;
            background: rgba(10, 8, 24, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100
        }

        #win.active {
            display: flex
        }

        .win-title {
            font-size: 36px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 30px #a855f7
        }

        .stars {
            font-size: 48px;
            margin: 20px 0
        }

        .next-btn {
            margin-top: 20px;
            padding: 14px 40px;
            font-size: 14px;
            font-weight: 700;
            color: #0a0818;
            background: linear-gradient(135deg, #a855f7, #ec4899);
            border: none;
            border-radius: 30px;
            text-transform: uppercase;
            letter-spacing: 3px
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            z-index: 50
        }

        .ctrl-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: rgba(255, 255, 255, 0.6)
        }
    </style>
</head>

<body>
    <canvas id="game"></canvas>
    <div id="hud">
        <div class="stat">
            <div class="stat-value" id="crystals">0/5</div>
            <div class="stat-label">crystals</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="level">1</div>
            <div class="stat-label">level</div>
        </div>
    </div>
    <div id="controls">
        <div class="ctrl-btn" id="up">▲</div>
        <div class="ctrl-btn" id="left">◀</div>
        <div class="ctrl-btn" id="down">▼</div>
        <div class="ctrl-btn" id="right">▶</div>
    </div>
    <div id="start">
        <div class="title">CRYSTAL</div>
        <div class="subtitle">Cavern Explorer</div>
        <button class="play-btn" id="play">EXPLORE</button>
    </div>
    <div id="win">
        <div class="win-title">LEVEL COMPLETE</div>
        <div class="stars" id="stars">⭐⭐⭐</div>
        <button class="next-btn" id="next">NEXT LEVEL</button>
    </div>
    <script>
        const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
        const crystalsEl = document.getElementById('crystals'), levelEl = document.getElementById('level'), starsEl = document.getElementById('stars');
        const startEl = document.getElementById('start'), winEl = document.getElementById('win');

        let W, H, playing = false, level = 1, collected = 0;
        let ball = { x: 0, y: 0, vx: 0, vy: 0 };
        let crystals = [], walls = [], particles = [];
        const TILE = 40, GRID = 10;

        function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight }
        window.addEventListener('resize', resize); resize();

        function generateLevel() {
            crystals = []; walls = []; collected = 0;
            const offsetX = (W - GRID * TILE) / 2, offsetY = (H - GRID * TILE) / 2;

            // Generate walls
            for (let i = 0; i < 5 + level * 2; i++) {
                walls.push({
                    x: offsetX + Math.floor(Math.random() * (GRID - 2) + 1) * TILE,
                    y: offsetY + Math.floor(Math.random() * (GRID - 2) + 1) * TILE,
                    w: TILE * (1 + Math.floor(Math.random() * 2)),
                    h: TILE
                });
            }

            // Generate crystals
            const count = 5;
            for (let i = 0; i < count; i++) {
                let valid = false, x, y;
                while (!valid) {
                    x = offsetX + Math.floor(Math.random() * (GRID - 2) + 1) * TILE + TILE / 2;
                    y = offsetY + Math.floor(Math.random() * (GRID - 2) + 1) * TILE + TILE / 2;
                    valid = !walls.some(w => x > w.x && x < w.x + w.w && y > w.y && y < w.y + w.h);
                }
                crystals.push({ x, y, collected: false, rotation: Math.random() * Math.PI * 2 });
            }

            ball.x = offsetX + TILE * 1.5; ball.y = offsetY + TILE * 1.5; ball.vx = 0; ball.vy = 0;
            crystalsEl.textContent = `0/${count}`;
        }

        let moveDir = { x: 0, y: 0 };

        function update() {
            if (!playing) return;

            ball.vx += moveDir.x * 0.5; ball.vy += moveDir.y * 0.5;
            ball.vx *= 0.95; ball.vy *= 0.95;
            ball.x += ball.vx; ball.y += ball.vy;

            const offsetX = (W - GRID * TILE) / 2, offsetY = (H - GRID * TILE) / 2;
            // Boundary
            ball.x = Math.max(offsetX + 15, Math.min(offsetX + GRID * TILE - 15, ball.x));
            ball.y = Math.max(offsetY + 15, Math.min(offsetY + GRID * TILE - 15, ball.y));

            // Wall collision
            walls.forEach(w => {
                if (ball.x > w.x - 15 && ball.x < w.x + w.w + 15 && ball.y > w.y - 15 && ball.y < w.y + w.h + 15) {
                    const cx = Math.max(w.x, Math.min(w.x + w.w, ball.x));
                    const cy = Math.max(w.y, Math.min(w.y + w.h, ball.y));
                    const dx = ball.x - cx, dy = ball.y - cy;
                    const dist = Math.hypot(dx, dy);
                    if (dist < 15 && dist > 0) {
                        ball.x = cx + dx / dist * 15; ball.y = cy + dy / dist * 15;
                        ball.vx *= -0.5; ball.vy *= -0.5;
                    }
                }
            });

            // Crystal collection
            crystals.forEach(c => {
                if (!c.collected && Math.hypot(ball.x - c.x, ball.y - c.y) < 25) {
                    c.collected = true; collected++;
                    crystalsEl.textContent = `${collected}/${crystals.length}`;
                    for (let i = 0; i < 8; i++)particles.push({ x: c.x, y: c.y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6, life: 1 });
                    if (collected >= crystals.length) winLevel();
                }
                c.rotation += 0.02;
            });

            particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.03 });
            particles = particles.filter(p => p.life > 0);
        }

        function draw() {
            ctx.fillStyle = '#0a0818'; ctx.fillRect(0, 0, W, H);

            const offsetX = (W - GRID * TILE) / 2, offsetY = (H - GRID * TILE) / 2;

            // Grid floor
            ctx.fillStyle = '#12101f';
            ctx.fillRect(offsetX, offsetY, GRID * TILE, GRID * TILE);

            // Grid lines
            ctx.strokeStyle = 'rgba(168,85,247,0.15)'; ctx.lineWidth = 1;
            for (let i = 0; i <= GRID; i++) {
                ctx.beginPath(); ctx.moveTo(offsetX + i * TILE, offsetY); ctx.lineTo(offsetX + i * TILE, offsetY + GRID * TILE); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(offsetX, offsetY + i * TILE); ctx.lineTo(offsetX + GRID * TILE, offsetY + i * TILE); ctx.stroke();
            }

            // Walls
            ctx.fillStyle = '#2a2040';
            walls.forEach(w => { ctx.beginPath(); ctx.roundRect(w.x, w.y, w.w, w.h, 6); ctx.fill() });

            // Crystals
            crystals.filter(c => !c.collected).forEach(c => {
                ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(c.rotation);
                ctx.fillStyle = '#a855f7'; ctx.shadowColor = '#a855f7'; ctx.shadowBlur = 15;
                ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(12, 0); ctx.lineTo(0, 15); ctx.lineTo(-12, 0); ctx.closePath(); ctx.fill();
                ctx.shadowBlur = 0; ctx.restore();
            });

            // Particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life; ctx.fillStyle = '#ec4899';
                ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill();
            }); ctx.globalAlpha = 1;

            // Ball
            ctx.fillStyle = '#fff'; ctx.shadowColor = '#fff'; ctx.shadowBlur = 10;
            ctx.beginPath(); ctx.arc(ball.x, ball.y, 15, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
        }

        function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop) }

        function startGame() { playing = true; level = 1; levelEl.textContent = '1'; generateLevel(); startEl.classList.add('hidden'); winEl.classList.remove('active'); window.parent?.postMessage({ type: 'GAME_STARTED' }, '*') }
        function winLevel() {
            playing = false;
            starsEl.textContent = level > 2 ? '⭐⭐⭐' : '⭐⭐';
            if (level >= 3) { document.getElementById('next').textContent = 'FINISH'; window.parent?.postMessage({ type: 'SCORE_UPDATE', score: level * 1000, final: true }, '*') }
            winEl.classList.add('active');
        }
        function nextLevel() { winEl.classList.remove('active'); if (level >= 3) { startEl.classList.remove('hidden'); return } level++; levelEl.textContent = level; generateLevel(); playing = true }

        // Controls
        ['up', 'down', 'left', 'right'].forEach(d => {
            document.getElementById(d).addEventListener('touchstart', e => { e.preventDefault(); moveDir = { up: { x: 0, y: -1 }, down: { x: 0, y: 1 }, left: { x: -1, y: 0 }, right: { x: 1, y: 0 } }[d] });
        });
        document.addEventListener('touchend', () => moveDir = { x: 0, y: 0 });
        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowUp') moveDir.y = -1; if (e.key === 'ArrowDown') moveDir.y = 1;
            if (e.key === 'ArrowLeft') moveDir.x = -1; if (e.key === 'ArrowRight') moveDir.x = 1;
        });
        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') moveDir.y = 0;
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') moveDir.x = 0;
        });
        document.getElementById('play').addEventListener('click', startGame);
        document.getElementById('next').addEventListener('click', nextLevel);

        window.addEventListener('message', e => { try { const d = typeof e.data === 'string' ? JSON.parse(e.data) : e.data; if (d.action === 'LIFECYCLE_PAUSE') playing = false; if (d.action === 'LIFECYCLE_RESUME' && startEl.classList.contains('hidden')) playing = true } catch (err) { } });
        window.parent?.postMessage({ type: 'READY' }, '*');

        gameLoop();
    </script>
</body>

</html>